; OM File Header - Saved 2014/04/05 14:05:10
; (6.080004 :lisp (om-make-point 280 10) (om-make-point 50 50) (om-make-point 500 400) "" 124 0 "2014/03/25 19:39:14" "2014/04/05 14:05:10")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-lisp-patch "SerieGenerator" 6.080004 ";;; Edit a valid LAMBDA EXPRESSION for \"SerieGenerator\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda () (om-beep))$$$(setq notas '(1 2 3 4 5 6 7 8 9 10 11 12))$(setq lista '(0 0 3 0 5 0 7 0 9 0 11 0))$(setq min 2)$(setq max 6)$$; function to rotate a list:$; (my-rotate (list 0 1 2 3 4 5)) -> (1 2 3 4 5 0)$; (my-rotate (list 0 1 2 3 4 5) 2) -> (2 3 4 5 0 1)$(defun my-rotate (list &optional (n 1))$(if (<= n 0) list (my-rotate (append (last list) (reverse (cdr (reverse list)))) (1- n))))$; function to randomize a list$(defun randomize-list (list)$(setf temp-list nil)$(dotimes (i (length list))$(setf list (my-rotate list (random (length list))))$(setf temp-list (push (car list) temp-list))$(pop list))$temp-list)$$$$$(defun myf (lista min max)$    ; Obtiene las notas que faltan en la secuencia parcial$  (setq notasfaltan (delete nil (remove-duplicates (loop for x in notas do$     collect (if (member x lista) nil x))  ; comprobar si x está en lista y si no está, añadir a notasfaltan$  )))$$  (setq notasfaltan (randomize-list notasfaltan)) ; reordenar aleatoriamente notasfaltan$$  (loop for x in notasfaltan do     ; para cada elemento de notasfaltan (bucle)$      ; seleccionar nueva nota y comprobar si cumple las restricciones$      ; obtener posición del primer 0$      ; en la posición -1 está la nota anterior$      (if (= 0 (position 0 lista)) ; Si es la primera posición de la lista$          ($          (setf (nth (position 0 lista) lista) x)$          (myf lista min max)$          )$$          (if (and ; Si no es la primera posición de la lista, miramos las restricciones$              (>= (if (> (abs (- x (nth (- (position 0 lista) 1) lista))) 6)$                  (- 6 (- (abs (- x (nth (- (position 0 lista) 1) lista))) 6))$                  (abs (- x (nth (- (position 0 lista) 1) lista)))) min)$              (<= (if (> (abs (- x (nth (- (position 0 lista) 1) lista))) 6)$                  (- 6 (- (abs (- x (nth (- (position 0 lista) 1) lista))) 6))$                  (abs (- x (nth (- (position 0 lista) 1) lista)))) max)$              )$              ($              (setf (nth (position 0 lista) lista) x); si las dos notas cumplen las restricciones, asigna la nueva nota en la posición del primer cero$              (if (not (position 0 (myf lista min max))); llama recursivamente a myf con la nueva lista$                                  ; si myf devuelve una lista completa entonces termina y devuelve la lista$                  (myf lista min max)$              )$              )$          )$      )$  )$  (if (position 0 lista)$      '(nil))$  ; si al terminar el bucle ninguna nota cumple la restricción devuelve lista vacía$)"))